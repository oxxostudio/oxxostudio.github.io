<!DOCTYPE html><html lang="zh-TW"><head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-control" content="public">
  <meta http-equiv="max-age" content="864000">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="author" content="oxxo.studio">
  <meta name="copyright" content="oxxo.studio">
  <script>
      let uri = window.location.href;
      if(uri.indexOf('https')<0 && uri.indexOf('localhost')<0){
          window.location.replace(uri.replace('http','https'));
      }
  </script>

  <title>簡單理解 JavaScript Async 和 Await - OXXO.STUDIO</title>

  <meta name="description" content="自從 Async 和 Await 出現後，大幅簡化 JavaScript 同步和非同步的複雜糾葛，這篇文章將會分享我自己理解的歷程，實作 await 等待、連續輸入文字、fetch 和迴圈應用，讓這些過去需要層層 callback 才能完成的流程，透過 Async 和 Await 輕鬆的進行扁平化處理吧！">
  <meta itemprop="description" content="自從 Async 和 Await 出現後，大幅簡化 JavaScript 同步和非同步的複雜糾葛，這篇文章將會分享我自己理解的歷程，實作 await 等待、連續輸入文字、fetch 和迴圈應用，讓這些過去需要層層 callback 才能完成的流程，透過 Async 和 Await 輕鬆的進行扁平化處理吧！">
  <meta itemprop="image" content="https://www.oxxostudio.tw/img/articles/201908/js-async-await.jpg">
  <meta property="og:description" content="自從 Async 和 Await 出現後，大幅簡化 JavaScript 同步和非同步的複雜糾葛，這篇文章將會分享我自己理解的歷程，實作 await 等待、連續輸入文字、fetch 和迴圈應用，讓這些過去需要層層 callback 才能完成的流程，透過 Async 和 Await 輕鬆的進行扁平化處理吧！">
  <meta property="og:title" content="簡單理解 JavaScript Async 和 Await">
  <meta property="og:url" content="https://www.oxxostudio.tw/articles/201908/js-async-await.html">
  <meta property="og:image" content="https://www.oxxostudio.tw/img/articles/201908/js-async-await.jpg">
  <link rel="canonical" href="https://www.oxxostudio.tw/articles/201908/js-async-await.html">
  <style>body{display:none;}</style>
</head>

<body>
  <div id="header">
    <div id="top-menu">
      <ul class="top-menu-left">
        <li class="list" title="文章列表"><i></i><a href="/list.html">ARCHIVE</a></li>
        <li class="about" title="關於我"><i></i><a href="/articles/201405/about-me.html">ABOUT</a></li>
        <li class="contact" title="聯絡方式"><i></i><a href="/articles/201405/contact.html">CONTACT</a></li>
      </ul>
      <a href="/sitemap.xml" title="Sitemap" target="_blank">
        <div class="rss"><i></i></div>
      </a>
      <div class="search" title="站內搜尋">
        <div id="cse-search-form" style="width: 100%;">
          <gcse:searchbox-only></gcse:searchbox-only>
        </div>
      </div>
    </div>
    <div id="banner">
      <a href="/">
        <i class="bubble"></i>
        <i class="hihi"></i>
        <img src="/img/layout/banner.png">
        <h2>Design thinking is everywhere</h2>
      </a>
    </div>
    <div id="main-menu">
      <div class="mobile-menu"><span></span><span></span><span></span></div>
      <div class="menu">
        <a href="/"><i></i>ALL</a>
        <a href="/index.html?tag-creative"><i></i>Creative</a>
        <a href="/index.html?tag-ui"><i></i>UI &amp; UX</a>
        <a href="/index.html?tag-photo"><i></i>PHOTO</a>
        <a href="/index.html?tag-css"><i></i>CSS</a>
        <a href="/index.html?tag-web"><i></i>WEB TECH</a>
        <a href="/index.html?tag-share"><i></i>Share</a>
        <a href="/index.html?tag-others"><i></i>OTHERS</a>
        <a href="/list.html"><i></i>ARCHIVE</a>
      </div>
    </div>
    <div class="body-line"></div>
  </div>

  <main>
    <article>
      <i class="tag"></i>

<h1>簡單理解 JavaScript Async 和 Await</h1> 
<p><img src="/img/articles/201908/js-async-await-s.jpg" class="preview-img" alt=""></p>
<p>自從 Async 和 Await 出現後，大幅簡化 JavaScript 同步和非同步的複雜糾葛，這篇文章將會分享我自己理解的歷程，實作 await 等待、連續輸入文字、fetch 和迴圈應用，讓這些過去需要層層 callback 才能完成的流程，透過 Async 和 Await 輕鬆的進行扁平化處理吧！</p>
<div id="google-adsense-content"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8629612872829139" data-ad-slot="2613902930" data-matched-content-ui-type="image_card_stacked" data-matched-content-columns-num="3" data-matched-content-rows-num="1" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><h2>什麼是 async？什麼是 await？</h2> 
<p>在 JavaScript 的世界，同步 sync 和非同步 async 的愛恨情仇，就如同偶像劇一般的剪不斷理還亂，特別像是<code>setTimeout</code>、<code>setInterval</code>、<code>MLHttpRequest</code>或<code>fetch</code>這些同步非同步混雜的用法，都會讓人一個頭兩個大，幸好 ES6 出現了 promise，ES7 出現了 async、await，幫助我們可以更容易的進行程式邏輯的撰寫。</p>
<p>對於同步和非同步，最常見的說法是「<em>同步模式下，每個任務必須按照順序執行，後面的任務必須等待前面的任務執行完成，非同步模式則相反，後面的任務不用等前面的，各自執行各自的任務</em>」，但我覺得這樣實在不容易理解，不容易理解的地方在於「中文」的同步和非同步，可能和實際上的解釋剛好相反了 ( 同步的中文字面意思是「一起走」，非同步的中文意思是「不要一起走」，超容易搞錯的 )，因此如果你跟我一樣也很容易搞錯，可以使用我覺得比較好理解的方法：「<strong>同一個步道 vs 不同步道</strong>」，透過步道的方式，就更容易明白同步和非同步。</p>
<blockquote>
<ul>
<li>同步：在「<em>同一個步道</em>」比賽「接力賽跑」，當棒子沒有交給我，我就得等你，不能跑。</li>
<li>非同步：在「<em>不 ( 非 ) 同步道</em>」比賽「賽跑」，誰都不等誰，只要輪到我跑，我就開始跑。</li>
</ul>
</blockquote>
<p><img class="lazy" src="/img/layout/loading.gif" data-src="/img/articles/201706/javascript-promise-settimeout-1.jpg" alt=""></p>
<p>在 ES7 裡頭 async 的本質是 promise 的語法糖 ( 包裝得甜甜的比較好吃下肚 )，<em>只要 function 標記為 async，就表示裡頭可以撰寫 await 的同步語法</em>，而 await 顧名思義就是「等待」，它會確保一個 promise 物件都解決 ( resolve ) 或出錯 ( reject ) 後才會進行下一步，當 async function 的內容全都結束後，會返回一個 promise，這表示後方可以使用<code>.then</code>語法來做連接，基本的程式長相就像下面這樣：</p>
<pre class="prettyprint"><code>async function a(){
  await b();
  .....       // 等 b() 完成後才會執行
  await c();
  .....       // 等 c() 完成後才會執行
  await new Promise(resolve=&gt;{
    .....
  });
  .....       // 上方的 promise 完成後才會執行
}
a();
a().then(()=&gt;{
  .....       // 等 a() 完成後接著執行
});
</code></pre><h2>利用 async 和 await 做個「漂亮的等待」</h2> 
<p>比較了解 async 和 await 的意思之後，就來試試看做個「<em>漂亮的等待</em>」，過去我在 <a href="/articles/201706/javascript-promise-settimeout.html#_self" target="_blank">JavaScript 同步延遲 ( Promise + setTimeout )</a> 一文裡，有使用 ES6 的 promise 來實現 delay ( 如同下方的程式範例 )，這個 delay 透過<code>.then</code>來完成一步一步的串接，雖然邏輯上很清楚，但若要實作比較複雜的流程，就得把每個程式寫在對應的 callback 裏，也就沒有想像的容易，這就是「不太漂亮的等待」 ( 使用 setTimeout 的做法就是不漂亮的等待 )。</p>
<pre class="prettyprint"><code>const delay = (s) =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(resolve,s); 
  });
};

delay().then(() =&gt; {
  console.log(1);     // 顯示 1
  return delay(1000); // 延遲ㄧ秒
}).then(() =&gt; {
  console.log(2);     // 顯示 2
  return delay(2000); // 延遲二秒
}).then(() =&gt; {
  console.log(3);     // 顯示 3
});
</code></pre><p>如果我們把上面的範例修改為 async 和 await 的寫法，突然就發現程式碼看起來非常的乾淨，因為<em> await 會等待收到 resolve 之後才會進行後面的動作，如果沒有收到就會一直處在等待的狀態</em>，所以什麼時候該等待，什麼時候該做下一步，就會非常清楚明瞭，這也就是我所謂「漂亮的等待」。</p>
<blockquote>
<p>注意，await 一定得運行在 async function 內！</p>
</blockquote>
<pre class="prettyprint"><code>~async function{           // ~ 開頭表示直接執行這個 function，結尾有 ()
  const delay = (s) =&gt; {
    return new Promise(function(resolve){  // 回傳一個 promise
      setTimeout(resolve,s);               // 等待多少秒之後 resolve()
    });
  };

  console.log(1);      // 顯示 1
  await delay(1000);   // 延遲ㄧ秒
  console.log(2);      // 顯示 2
  await delay(2000);   // 延遲二秒
  console.log(3);      // 顯示 3
}();
</code></pre><h2>搭配 Promise</h2> 
<p>基本上只要有 async 和 await 的地方，就一定有 promise 的存在，promise 顧名思義就是「保證執行之後才會做什麼事情」，剛剛使用了 async、await 和 promise 改善<code>setTimeout</code>這個容易出錯的非同步等待，針對<code>setInterval</code>，也能用同樣的做法修改，舉例來說，下面的程式碼執行之後，並「<em>不會</em>」如我們預期的「<em>先顯示 1，再顯示 haha0...haha5，最後再顯示 2</em>」，而是「<em>先顯示 1 和 2，然後再出現 haha0...haha5</em>」，因為雖然程式邏輯是從上往下，但在 count function 裏頭是非同步的語法，導致自己走自己的路，也造成了結果的不如預期。</p>
<pre class="prettyprint"><code>const count = (t,s) =&gt; {
  let a = 0;
  let timer = setInterval(() =&gt; {
    console.log(`${t}${a}`);
    a = a + 1;
    if(a&gt;5){
      clearInterval(timer);
    }
  },s);
};

console.log(1); 
count('haha', 100);
console.log(2);
</code></pre><p><img class="lazy" src="/img/layout/loading.gif" data-src="/img/articles/201908/js-async-await-01.jpg" alt=""></p>
<p>這時我們可以透過 async、await 和 promise 進行修正，在顯示 1 之後，會「<em>等待</em>」count function 結束後再顯示 2。</p>
<pre class="prettyprint"><code>~async function(){  
  const count = (t,s) =&gt; {
      return new Promise(resolve =&gt; {
        let a = 0;
        let timer = setInterval(() =&gt; {
          console.log(`${t}${a}`);
          a = a + 1;
          if(a&gt;5){
            clearInterval(timer);
            resolve();  // 表示完成
          }
        },s);
      });
    };

  console.log(1); 
  await count('haha', 100);
  console.log(2);
}();
</code></pre><p><img class="lazy" src="/img/layout/loading.gif" data-src="/img/articles/201908/js-async-await-02.jpg" alt=""></p>
<p>除了<code>setTimeout</code>和<code>setInterval</code>，這也可以用於像是「<em>輸入文字</em>」的情境，過去我們要做到「<em>連續輸入</em>」文字，可能要層層疊疊寫個好幾個 callback，現在如果使用 async 和 await，就能夠很簡單的實現連續輸入的情境，程式碼看起來也更乾淨簡潔。</p>
<pre class="prettyprint"><code>// HTML 為一個輸入框、一個按鈕和一個 h1 標籤
// &lt;input id="a"&gt;&lt;/input&gt;&lt;button id="b"&gt;send&lt;/button&gt;
// &lt;h1 id="h"&gt;&lt;/h1&gt;

~async function(){
  const input = () =&gt; {
    return new Promise(resolve =&gt;{  
      const btnClick = () =&gt;{
        h.insertAdjacentHTML('beforeend', a.value + '&lt;br/&gt;');   // 輸入後在 h1 裡添加內容
        a.value = '';   // 清空輸入框
        a.focus();      // 將焦點移至輸入框
        b.removeEventListener('click', btnClick);  // removeEventListener 避免重複綁定事件
        resolve();      // 完成
      };
      b.addEventListener('click', btnClick); // 綁定按鈕事件
    });
  };
  h.insertAdjacentHTML('beforeend', '開始&lt;br/&gt;');
  await input();     //  等待輸入，輸入後才會進行下一步
  await input();
  await input();
  h.insertAdjacentHTML('beforeend', '結束');
}();
</code></pre><p><img class="lazy" src="/img/layout/loading.gif" data-src="/img/articles/201908/js-async-await-03.gif" alt=""></p>
<h2>搭配 Fetch</h2> 
<p>在我之前的文章<a href="/articles/201908/js-fetch.html#_self" target="_blank">JavaScript Fetch API 使用教學</a>已經有提到<code>fetch</code>的用法，因為<code>fetch</code>最後回傳的是 promise，理所當然的透過 async 和 await 操作是最恰當不過的。</p>
<p>舉例來說，先前往 <a href="https://opendata.cwb.gov.tw/index" target="_blank">中央氣象局開放資料平台</a>可以取得許多氣象資料，找到 <a href="https://opendata.cwb.gov.tw/dataset/observation/O-A0003-001" target="_blank">局屬氣象站-現在天氣觀測報告</a>，複製 JSON 格式的連結 ( 需要註冊登入才能看得到連結 )，透過<code>fetch</code>的<code>json()</code>方法處理檔案，目標顯示出「高雄市的即時氣溫」。</p>
<p>透過 async 和 await 的美化程式碼，得到的結果完全不需要 callback 的輔助，就能按照我們所期望的順序進行。( 先顯示「開始抓氣象」，接著顯示「高雄市的氣溫」，最後顯示「總算結束了」 )</p>
<pre class="prettyprint"><code>~async function(){
    console.log('開始抓氣象');       // 先顯示「開始抓氣象」
    await fetch('氣象局 json 網址')  // 帶有 await 的 fetch
    .then(res =&gt; {
        return res.json();
    }).then(result =&gt; {
        let city = result.cwbopendata.location[14].parameter[0].parameterValue;
        let temp = result.cwbopendata.location[14].weatherElement[3].elementValue.value;
        console.log(`${city}的氣溫為 ${temp} 度 C`); 
    });
    console.log('總算結束了');       // 抓完氣象之後再顯示「總算結束了」
}();
</code></pre><p><img class="lazy" src="/img/layout/loading.gif" data-src="/img/articles/201908/js-async-await-04.jpg" alt=""></p>
<h2>搭配 迴圈</h2> 
<p>如果要透過 JavaScript 實現「文字慢慢變大」的效果，除了透過 CSS 的 transition 設定之外，通常就是直接使用<code>setInterval</code>來完成，就像下面的程式碼這樣：</p>
<pre class="prettyprint"><code>let size = 30;
h.style.lineHeight = 0;
const timer = setInterval(()=&gt;{
  h.style.fontSize = size + 'px';
  size = size + 1;
  if(size &gt;= 130){
    clearInterval(timer);
  }
},10);
</code></pre><p>如果搭配 async 和 await，我們就能將同樣的做法，改由「迴圈」實現，因為使用了 await，所以迴圈每次執行時，都會進行「等待」，也就能做到字體慢慢變大的效果。</p>
<pre class="prettyprint"><code>// HTML 為一個 h1 標籤 &lt;h1 id="h"&gt;hello&lt;/h1&gt;

~async function(){
  const delay = t =&gt; {    // 先撰寫一個等待的 function
    return new Promise(resolve =&gt; {
      setTimeout(resolve, t);
    });
  };
  h.style.linHeight = 0;
  for(let i=30; i&lt;130; i++){
    h.style.fontSize = i + 'px';
    await delay(10);    // 迴圈每次執行時，都會在這裡等待 10ms
  }
}();
</code></pre><p><img class="lazy" src="/img/layout/loading.gif" data-src="/img/articles/201908/js-async-await-05.gif" alt=""></p>
<p>同樣的，上面提到的 fetch 或是輸入文字，只要做成 await 的方式，都可以放在迴圈裡面使用，例如透過迴圈不斷的 fetch 資料、透過迴圈不斷的輸入文字...等，這些就不是 callback 方法能容易辦到的囉～</p>
<h2>小結</h2> 
<p>坦白說只要你一但熟悉了 async 和 await，就真的回不去了，雖然說 callback 仍然是程式開發裡必備的功能，但對於同步和非同步之間的轉換，以後就交給 async 和 await 來處理吧！</p>


      <div class="social-icon">
        <a class="icon-home" href="/index.html"><i></i><span>Back Home</span></a>
        <a class="icon-list" href="/list.html"><i></i><span>Article List</span></a>
        <a class="icon-facebook" target="_blank"><i></i><span>Share on Facebook</span></a>
        <a class="icon-google" target="_blank"><i></i><span>Share on Google+</span></a>
        <a class="icon-twitter" target="_blank"><i></i><span>Share on Twitter</span></a>
        <a class="goto-top"><i></i><span>Back to Top</span></a>
      </div>
      <a class="arrow arrow-left">
        <i></i>
      </a>
      <a class="arrow arrow-right">
        <i></i>
      </a>

    </article>
  </main>
  <div class="recommend">
      <div class="closeBtn"></div>
      <h4>有興趣瞧瞧其他新文章嗎？</h4>
      <ul></ul>
  </div>
  <div id="other-articles">
    <div class="previous-next previous-article">
      <span>前一篇文章：</span>
      <br>
      <h4></h4>
    </div>
    <div class="previous-next next-article">
      <span>下一篇文章：</span>
      <br>
      <h4></h4>
    </div>
    <h3>您可以閱讀其他相關文章，或瀏覽 <a href="/list.html">所有文章</a></h3>
  </div>
  <div id="google-adsense">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8629612872829139" data-ad-slot="8489880299" data-matched-content-ui-type="image_card_stacked" data-matched-content-rows-num="1" data-matched-content-columns-num="4" data-ad-format="autorelaxed"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </div>
  <div id="disqus">
    <div id="disqus_thread"></div>
  </div>
  <div id="footer">
    <div class="footer-line"></div>
    <div class="license">Copyright 2019 | All Rights Reserved. Designed by <a href="/">OXXO.STUDIO</a></div>
  </div>

  <link href="/css/article.css?20190821" rel="stylesheet">
  <script src="https://www.google.com/jsapi"></script>
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-2708968-3', 'auto');
    ga('send', 'pageview');
  </script>
  <script src="/js/layout.js?20190612"></script>
  <script src="/js/articles.js?20190724"></script>
  <!-- highlight -->
  <style>
  .hljs{display:block;overflow-x:auto;padding:20px;background:#232323;color:#e9e9e9}.hljs-comment,.hljs-quote{color:#bc9458;font-style:italic}.hljs-keyword,.hljs-selector-tag{color:#c26230}.hljs-string,.hljs-number,.hljs-regexp,.hljs-variable,.hljs-template-variable{color:#a5c261}.hljs-subst{color:#519f50}.hljs-tag,.hljs-name{color:#e8bf6a}.hljs-type{color:#da4939}.hljs-symbol,.hljs-bullet,.hljs-built_in,.hljs-builtin-name,.hljs-attr,.hljs-link{color:#6dacde;}.hljs-params{color:#d0d0ff}.hljs-attribute{color:#cda869}.hljs-meta{color:#9b859d}.hljs-title,.hljs-section{color:#ffc66d}.hljs-addition{background-color:#144212;color:#e6e1dc;display:inline-block;width:100%}.hljs-deletion{background-color:#600;color:#e6e1dc;display:inline-block;width:100%}.hljs-selector-class{color:#9b703f}.hljs-selector-id{color:#8b98ab}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:bold}.hljs-link{text-decoration:underline}
  </style>
  <script src="/js/lib/highlight.pack.js"></script>
  <script>
    document.querySelectorAll('pre code').forEach(e => {
      hljs.highlightBlock(e);
    });
  </script>
  <script>
    const showAD = () => {
      let element = document.createElement("script");
      element.src = "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
      document.body.appendChild(element);
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8629612872829139",
        enable_page_level_ads: true
      });
      window.removeEventListener('scroll', showAD);
    }
    window.addEventListener('scroll', showAD);
  </script>
  <script>
    const showDisqus = () => {
      let scrollTop = this.pageYOffset;
      let bodyHeight = document.body.clientHeight;
      if (scrollTop > bodyHeight / 2) {
        let dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//oxxostudio.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        window.removeEventListener('scroll', showDisqus);
      }
    };
    window.addEventListener('scroll', showDisqus);
  </script>



</body></html>